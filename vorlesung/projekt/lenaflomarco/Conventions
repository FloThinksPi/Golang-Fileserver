
Rule #1 KISS , no extra work !!!

#### Naming Convention #######

    -Packages and Files start with a Capital letter.
    -Packages and Files use CamelCase.

    -Constants are all CAPITAL

    -Variables start small and use camelCase

    -Structs and Interfaces are normal CamelCase

#### Code Guideline #########

    -Important code goes first, Import statements, related groups separated by blank lines.

    -The rest of the code starting with the most significant types, and ending
    with helper function and types.

    -Avoid very long files

    -Separated package documentation
    When we have more than one file in a package, it's convention to create a Doc.go
    containing the package documentation.

#### Logging ########

    Error 	means that the execution of some task could not be completed
            an email couldn't be sent, a page couldn't be rendered, some data couldn't be stored to a database,
            something like that. Something has definitively gone wrong.
    Utils.LogError(...)

    Warning means that something unexpected happened, but that execution can continue, perhaps in a degraded mode
            a configuration file was missing but defaults were used, a price was calculated as negative,
            so it was clamped to zero, etc. Something is not right, but it hasn't gone properly wrong yet
            - warnings are often a sign that there will be an error very soon.
    Utils.LogWarning(...)

    Info 	means that something normal but significant happened
            the system started, the system stopped, the daily inventory update job ran, etc.
            There shouldn't be a continual torrent of these, otherwise there's just too much to read.
    Utils.LogInfo(...)

    Debug 	means that something normal and insignificant happened
            new user came to the site, a page was rendered,	an order was taken, a price was updated.
            This is the stuff excluded from info because there would be too much of it.
    Utils.LogDebug(...)

#### Error Handling #########

    Create errors
            errors.New("Erster Fehler")

    Stack Errors onto each other
            errors.Wrap(oldError,"New Error Text")

    Handle for Errors
        if err != nil {
            //DO HANDLING HERE
        }

    Handle Shortcuts(simplify some handling cases)
        Utils.HandlePrint(err) // Prints Error if a error is Found WITH STACKTRACE!
        Utils.HandlePanic(err) // Prints Error if a error is Found and PANICS = runs defer statements backwards to main
                                  and exits with error 1

    Handling Rulese
        - On unrecoverable error, call panic or use HandlePanic! Dont just quit with os.exit(1)
        - If you cant handle the error return it to next function
        - If Error comes from Internal function, Wrap it and add context why selfwritten function failed
          and what you where trying


### Documentation #######

    -Pro Paket in doc.go eine Paketdoku
    -Nach Konvention von GoDoc jede Funktion dokumentieren, damit automatisch eine Programmdoku generiert werden kann!